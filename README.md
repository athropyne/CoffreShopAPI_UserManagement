# Управление пользователями 
## Функционал:
* регистрация пользователей
* просмотр собственного профиля
* иземение данных профиля ( доступно только владельцу аккаунта и администратору )
* получения профиля по ID ( доступно только администратору )
* получение списка пользователей ( доступно только администратору )
* удаление пользователя ( доступно только администратору )
* аутентификация
* обновление токенов 
* повторная отправка кода верификации на email
* верификация пользователя ( подтверждение email через код верификации, доступно только аутентифицированным пользователям )
* фейковый почтовый клиент ( конечная точка имитирующая вход на почтовый клиент с получением письма )

## Инфраструктура и библиотеки:
* python 3.11
* postgresql (asyncpg)
* sqlalchemy core (async)
* redis
* arq
* fastapi
* aiosmtpd  ( для эмуляции почтового сервера )

## Особенности:
* аккаунты с неподтверженным email удаляются втечение 2х дней
* при первом запуске приложения администратор регистрируется автоматически, подтверждать его не нужно.

## Косяки
* документация на русском ( автор знает язык настолько чтобы называть переменные "tree", а не "derevo", но недостаточно чтобы написать синтаксически и морфологически приемлемую документацию, поэтому пишет на том что знает ).
* не доработан запуск через docker (не успел). Ручной запуск (о нем ниже) протестирован и работает. При запуске через docker compose нет отклика от почтового сервера и/или брокера ( косяк связан с внутренним dns, доделаю как буду дома ), поэтому не будут приходить письма и не будет удаляться пользователь после 2х дней неподтверденного email.
* почтовый сервер поднимается локально, ради экономии времени, как настроить приложение на работу с рельным почтовым сервисом знаю, но для этого нужен будет аккаунт настроенный на работу с внешними программами (не удобно для разработки).
* для отложенных задач использован arq. (celery упорно отказался работать, причину выяснял часов 6, исправить можно либо разработкой в linux (который я снес с неделю назад, поставлю другой), либо настройкой разработки через docker.
 taskiq вел себя так же непредсказуемо. Решено взять arq чтобы просто выполнить задачу). 
* забыл включить пример .env файла в коммит )), но настройка интуитивно должна быть понятна, переменные окружения должны совпадать с полями класса src.core.config.Settings.
* нет ORM (но это не косяк, автор всегда так пишет. Это быстрее работает, больше гибкости, полный контроль над запросами, возможность использования нативных возможностей субд).
* почтовый сервер (файл fake_smtp_server.py) находится в корне проекта, хотя по идее должен быть отдельным проектом (небольшой косячок со структурой. опять же не хватило времени).

## Запуск
~docker compose up~
*перед запуском ознакомтесь с конфигурацией и измените нужные настройки* ```src.core.config.py::Settings``` или создайте .env файл с соответствующими переменными
запустите postgresql, создайте базу данных с именем указанным в настройках. Запустите redis.
1. запустить основное приложение ```python main.py```
2. запустить почтовый сервер ```python fake_smtp_server.py```
3. запустить планировщик ```arq src.app.WorkerSettings```
4. откройте openai по адресу http://<host>:<port>/docs

## PS
Все косячки исправлю как буду дома (у меня есть работа на которой я сутками из за чего не успел сделать все красиво, хочу ее поменять). Нужно ваше мнение по поводу архитектурных подходов, стилистике кода. Все выполнено в слоистой архитектуре и должно быть интуитивно понятно. Есть пакет core отвечающий за внешние сервисы , инфраструктуру, схемы данных и общие классы интерфейсы, утилиты.
есть пакет services, отвечающий за работу с конкретными сущностями (кстати регистрацию пользователей никогда не ставлю на ту же полку что и авторизацию, а вход в систему помещаю в путь /security где помимо авторизации может находиться то что находится сейчас + обновление учетных данных аккаунта с подтверждением или других чувствительных данных. Все что связано с пользователями, в том числе их создание в /users. Такая архитектура позволит поэтапно разделить приложение на микросервисы, сначала распределить монолит (оставить общую базу для разных сервисов), потом разделить сами данные. *Код может быть непричесанным*, опять же из за нехватки времени возможно где то остались неиспользуемые или закомментированные участки кода. Как и сама эта документация может иметь неточности, потому как пишу ее с телефона по памяти.


